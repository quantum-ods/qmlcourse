---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(bra-ket)=
# Ско бки

Дисклеймер: нам нужен инструментарий для работы с более абстрактными пространствами!

Символ Кронекера и остальные специальные тензора -- это удобные примитивы для низкоуровневой работы с матрицами и векторами.
Физики смогли придумать поверх примитивов линейной алгебры отличный синтаксический сахар, т.н. нотацию Дирака. Но давайте начнем с определения гильбертово пространства.

- Гильбертово пространство

Гильбертово пространство определяется:
1) скалярным произведением (u, v) (в простейшем частном случае - $(u, v) = u^{\dagger} v$)
2) зафиксированной нормой вида $||v|| = \sqrt{(v,v)}$
3) является полным с метрикой $d(u,v) = ||u-v|| = \sqrt{(u-v,u-v)}$

- Полное пространство

Полное метрическое пространство дает возможность не думать при нахождении предела некоторой последовательности о принадлежности этого предела данному пространству, то есть по своей сути разрешает предельный переход и позволяет доказать множество красивых теорем. Подробнее строгое определение можно посмотреть [тут](https://ru.wikipedia.org/wiki/Полное_метрическое_пространство)

- Нотация Дирака или Bra-Ket нотация

Напомним, что в гильбертовом пространстве у нас есть к пространству $H$ сопряженное пространство $H^{\dagger}$.
Тогда можно рассмотреть обозначение Ket для элемента $v$ из $H$ как вектор столбец

$$
\ket{v} = \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{pmatrix}
$$

и обозначение Bra для элемента $u$ из сопряженного пространства $H^*$ как сопряженную вектор строку

$$
\bra{u}= \begin{pmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{pmatrix}
$$

тогда bra-ket u и v просто задает скалярное произведение между этими элементами:

$$
\bra{u} \ket{v} = u_1^* v_1 + u_2^* v_2 + \cdots + u_N^* v_N =
\begin{pmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{pmatrix}
\begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{pmatrix}
$$

Часто, например, требуется показать два граничных  состояния кубита $|0>$, $|1>$, тогда мы можем записать их просто как вектора столбцы: $\ket{0} = \begin{pmatrix} 1 \\ 0 \end{pmatrix}$ и $\ket{1} = \begin{pmatrix} 0 \\ 1 \end{pmatrix}$. В следующей лекции этот вопрос будет рассмотрен детальнее.

- Внешнее произведение (outer-product)

Также имеет смысл и переставленная запись, которая называется внешним произведением:

$$
\ket{u} \bra{v} = \begin{pmatrix} u_1^* & u_2^* & \cdots & u_N^* \end{pmatrix} \begin{pmatrix} v_1 \\ v_2 \\ \vdots \\ v_N \end{pmatrix} = \begin{pmatrix}
  u_1^* v_1 & u_1^* v_2 & \cdots & u_1^* v_N \\
  u_2^* v_1 & u_2^* v_2 & \cdots & u_2^* v_N \\
  \vdots & \cdots &  \ddots & \vdots\\
  u_N^* v_1 & \cdots & \cdots & u_N^* v_N
\end{pmatrix}
$$

по сути это матрица N x N, то есть новый оператор в гильбертовом пространстве. Не все перестановки имеют смысл, например, нельзя записать $\bra{v} \bra{v}$ или $\ket{u} \ket{v}$.

- Эрмитов оператор

Оператор U называется [_эрмитовым_](https://ru.wikipedia.org/wiki/%D0%AD%D1%80%D0%BC%D0%B8%D1%82%D0%BE%D0%B2_%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%82%D0%BE%D1%80), если он удовлетворяет равенству $(Uv,u) = (v,Uu)$ для всех $u$, $v$ из $H$ или в матричном виде:

$$
U=U^{\dagger}
$$

- Унитарный оператор

Унитарный оператор $\hat{U}:H \rightarrow H$ на гильбертовом пространстве $H$ это линейный оператор, который удовлетворяет следующему равенству $(Uv, Uu) = (u,v)$ для любых $v \in H$, $u \in H$. Или в матричной форме:

$$
\hat{U}^{\dagger}\hat{U}=\hat{U}\hat{U}^{\dagger}=I
$$

напомним, что операция $\hat{U}^\dagger$ (другое частое обозначение в работах - звездочка или H $\hat{U}^{*}=\hat{U}^{H}$) в матричных терминах является последовательным применением операции транспонирования и последующего сопряжения элементов этой матрицы $\hat{U}^\dagger = \overline{\hat{U}}^T$ (порядок этих операций, естественно не влияет на результат).

```{code-cell} ipython3
import numpy as np
import scipy as sp
from scipy import linalg
U_hat = np.array([
    [1 + 0j, 0 + 0j],
    [0 + 0j, 1 + 0j]
    ])
U_hat_star_byhands = U_hat.conj().T
U_hat_star_long = np.conjugate(np.transpose(U_hat))

print(np.allclose(U_hat_star, U_hat_star_byhands))
```
Также в python для многих операций есть соответствующие методы вместо функций и их сокращения, например U.transpose() тоже самое, что U.T, а U.conjugate() - U.conj()

Важное свойство, что любой эрмитов оператор U можно привести к унитарному оператору с помощью взятия матричной экспоненты от матрицы оператора умноженного на мнимую единицу:

$$
\hat{U} = \exp(iU)
$$

Давайте докажем быстро этот факт: для эрмитовых квадратных матриц можно определить матричные функции через спектральное разложение матрицы, которое в силу свойств эрмитовых матриц имеет вид: $U=S \Lambda S^{\dagger}$, где $S$ - унитарная матрица перехода к тому базису, где изначальный оператор выражается диагональной матрицей. Тогда матричная функция $f(U) = $S f(\Lambda) S^{\dagger}$, т.е. мы диагонализируем матрицу и применяем функцию ко всем диагональным элементам, а потом возвращаемся в исходный базис унитарным преобразованием. Соответственно для экспоненты:
$$
\exp V = S \exp (\Lambda) S^\dagger
$$

```{note}
В качестве упражнения для самопроверки можете показать, что такое определение эквивалентно определению через степенной ряд: $e^U = \sum_{k=0}^\infty{1 \over k!}U^k$
```

Доказательство:
Проверим определение унитарной матрицы: $\hat{U}^{\dagger}\hat{U} = (S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger$.
Пользуясь тем, что эрмитово сопряжение переставляет матрицы и является обратной операцией к себе же и так как S - унитарная матрица (то есть $S S^{\dagger}=I$) получаем:

$$
(S \exp (i*\Lambda) S^\dagger)^\dagger S \exp (i*\Lambda) S^\dagger = \exp(-i*\Lambda) S^\dagger  S \exp (i*\Lambda)  S^\dagger
$$

Заметим, что теперь у нас уже скалярная экспонента, которая применяется к элементам диагональной матрицы и мы можем воспользоваться тем, что произведение экспонент превращается в экспоненту от суммы степеней

$$
S \exp(-i \Lambda  + i \Lambda) S^\dagger = S \exp(O) S^\dagger = S I S^\dagger = I
$$

В конце мы еще раз воспользовались тем, что S - унитарная. Абсолютно также доказывается, что $\hat{U}\hat{U}^{\dagger}$
``` note
Кстати, любая матрица вида $HH^{\dagger}$ является эрмитовой
```
Давайте продемонстрируем доказанный факт на примере матрицы дискретного преобразования Фурье без нормировочного коэффициента $\frac{1}{N}$, $N=3$ преобразованной к $DD^{dagger}:

```{code-cell} ipython3
N=3
w = np.sqrt(np.exp(-1j*2*np.pi/N))
D = np.array([
    [1, 1, 1],
    [1, w, w**2],
    [1, w**2, w**4]
    ])
print(U)

U = D @ D.conj().T
print(D)
print(np.allclose(U @ U.H, np.eye(N))) # no

U_hat = linalg.expm(np.i*U)
print(np.allclose(U_hat @ U_hat.conj().T, np.eye(N)))
print(np.allclose(U_hat.conj().T @ U_hat, np.eye(N)))
```

- Пример: оператор проектор

Оператором проекции является оператор $P$ со свойством $P^2=P$

- Пример: оператор поворота

Оператор поворота по оси вращения $v=(x,y,z)$ на угол $\theta$ является

$$
M(v,\theta) = \begin{pmatrix}
   \cos \theta + (1 - \cos \theta) x^2
 & (1 - \cos \theta) x y - (\sin \theta) z
 & (1 - \cos \theta) x z + (\sin \theta) y  
\\
   (1 - \cos \theta) y x + (\sin \theta) z
 & \cos \theta + (1 - \cos \theta) y^2
 & (1 - \cos \theta) y z - (\sin \theta) x
\\
   (1 - \cos \theta) z x - (\sin \theta) y
 & (1 - \cos \theta) z y + (\sin \theta) x
 & \cos \theta + (1 - \cos \theta) z^2
\end{pmatrix}
$$

Например, если мы хотим повернуть относительно оси x на $90^\degree$: $x=1$, $y=0$, $z=0$, $\theta = \frac{\pi}{2}, наша матрица будет иметь вид:

$$
M = \begin{pmatrix}
1 & 0 & 0 \\
0 & \cos{\frac{\pi}{2}} & -\sin{\frac{\pi}{2}} \\
0 & \sin{\frac{\pi}{2}} & 1 \end{pmatrix}
$$

Если у нас больше измерений, то по тем измерениям, которые не затрагиваются этим поворотом у нас в строке и столбце стоят нули, кроме пересечения строки и столбца, отвечающим за это измерение - там стоит единица.

- Пример: оператор дифференцирования
в пространстве многочленов $P$ с базисом \{1,t,t^2,...,t^n\} можно задать оператор дифференцирования $\mathcal{D} \colon P_n \to P_{n-1}$ в виде матрицы:

$$
D=\begin{pmatrix}
0 & 1 & 0 & 0 & \cdots & 0 \\
0 & 0 & 2 & 0 & \cdots & 0 \\
0 & 0 & 0 & 3 &\cdots & 0 \\
\cdots & \cdots & \cdots & \cdots &\cdots & \cdots \\
0 & 0 & 0 & 0 &\cdots & n \\
\end{pmatrix}
$$

тогда производная многочлена $p = a_0 + a_1 t  + \cdots + a_n t^{n} = \begin{pmatrix} a_0 & a_1 & \cdots & a_n \end{pmatrix} \begin{pmatrix} 1 \\ t \\ \vdots \\ t^{n} \end{pmatrix}$

$$
\mathcal{D}(p)  = \begin{pmatrix} a_0 & a_1 & \cdots & a_n \end{pmatrix} D \begin{pmatrix} 1 \\ t \\ \vdots \\ t^{n-1} \end{pmatrix} = a_1 + 2 a_2 t+\cdots+n a_n t^{n-1}
$$

- Про разницу между оператором и матрицей преобразования

Мы с вами рассматривали операторы, через конечные матрицы, но на самом деле Гильбертово пространство было придумано как раз, чтобы можно было работать с бесконечномерными векторами и применять непрерывные операторы. Можно считать, что есть некоторый дуализм между непрерывным оператором и пределом бесконечной матрицы. Иногда удобнее работать с матрицей, а иногда - с абстрактным оператором.

- Произведение Кронекера

Давайте рассмотрим еще одну интересную операцию, которая называется тензорным произведением или произведением Кронекера.

Проще всего его необходимость можно продемонстрировать на примере двух игр: Орел/Решка и бросок кубика.
Мы можем записать состояния этих игр через вероятности событий и давайте возьмем монетку со смешенным центром тяжести и такой же кубик:

$\text{coin} = \begin{pmatrix} \frac{1}{3} && \frac{2}{3} \end{pmatrix}$ для нашей монетки и $\text{dice}=\begin{pmatrix} \frac{1}{4} && \frac{1}{5} && \frac{1}{7} && \frac{1}{11} && \frac{1}{13} && \frac{4791}{20020} \end{pmatrix}$ для нашей игральной кости. Тогда, допустим мы захотим сыграть в игру, когда сначала подкидывается монетка, а потом - игральный кубик нам будет удобно записать это в виде либо очень длинного вектора:

$$
\text{game}_{\text{vec}} = \begin{pmatrix} \frac{1}{3} \times \frac{1}{4} && \frac{1}{3} \times \frac{1}{5} && \frac{1}{3} \times \frac{1}{7} && \frac{1}{3} \times \frac{1}{11} && \frac{1}{3} \times \frac{1}{13} && \frac{1}{3} \times \frac{4791}{20020}&& \frac{2}{3} \times \frac{1}{4} && \frac{2}{3} \times \frac{1}{5} && \frac{2}{3} \times \frac{1}{7} && \frac{2}{3} \times \frac{1}{11} && \frac{2}{3} \times \frac{1}{13} && \frac{2}{3} \times \frac{4791}{20020} \end{pmatrix}
$$

Или в виде матрицы, где по строкам будут события монетки, а по столбцам - кубика:

$$
\text{game}_{\text{matrix}} = \begin{pmatrix} \frac{1}{3} \times \frac{1}{4} && \frac{1}{3} \times \frac{1}{5} && \frac{1}{3} \times \frac{1}{7} && \frac{1}{3} \times \frac{1}{11} && \frac{1}{3} \times \frac{1}{13} && \frac{1}{3} \times \frac{4791}{20020}\\
 \frac{2}{3} \times \frac{1}{4} && \frac{2}{3} \times \frac{1}{5} && \frac{2}{3} \times \frac{1}{7} && \frac{2}{3} \times \frac{1}{11} && \frac{2}{3} \times \frac{1}{13} && \frac{2}{3} \times \frac{4791}{20020} \end{pmatrix}
$$

С помощью произведения Кронекера (или повторимся - тензорного произведения) похожие огромные вектора и матрицы можно очень компактно записать:

$$
\text{game}_{\text{vec}} = \text{coin} \otimes \text{dice} \\
\text{game}_{\text{matrix}} = \text{coin}^T \otimes \text{dice}
$$

В общем случае,

$$
A \otimes B = \begin{pmatrix} a_{11} B & \cdots & a_{1n}B \\ \vdots & \ddots & \vdots \\ a_{m1} B & \cdots & a_{mn} B \end{pmatrix} =\begin{pmatrix}
   a_{11} b_{11} & a_{11} b_{12} & \cdots & a_{11} b_{1q} & \cdots & \cdots & a_{1n} b_{11} & a_{1n} b_{12} & \cdots & a_{1n} b_{1q} \\
   a_{11} b_{21} & a_{11} b_{22} & \cdots & a_{11} b_{2q} & \cdots & \cdots & a_{1n} b_{21} & a_{1n} b_{22} & \cdots & a_{1n} b_{2q} \\
   \vdots & \vdots & \ddots & \vdots & & & \vdots & \vdots & \ddots & \vdots \\
   a_{11} b_{p1} & a_{11} b_{p2} & \cdots & a_{11} b_{pq} & \cdots & \cdots & a_{1n} b_{p1} & a_{1n} b_{p2} & \cdots & a_{1n} b_{pq} \\
   \vdots & \vdots & & \vdots & \ddots & & \vdots & \vdots & & \vdots \\
   \vdots & \vdots & & \vdots & & \ddots & \vdots & \vdots & & \vdots \\
   a_{m1} b_{11} & a_{m1} b_{12} & \cdots & a_{m1} b_{1q} & \cdots & \cdots & a_{mn} b_{11} & a_{mn} b_{12} & \cdots & a_{mn} b_{1q} \\
   a_{m1} b_{21} & a_{m1} b_{22} & \cdots & a_{m1} b_{2q} & \cdots & \cdots & a_{mn} b_{21} & a_{mn} b_{22} & \cdots & a_{mn} b_{2q} \\
   \vdots & \vdots & \ddots & \vdots & & & \vdots & \vdots & \ddots & \vdots \\
   a_{m1} b_{p1} & a_{m1} b_{p2} & \cdots & a_{m1} b_{pq} & \cdots & \cdots & a_{mn} b_{p1} & a_{mn} b_{p2} & \cdots & a_{mn} b_{pq}
\end{pmatrix}
$$

основные его свойства вы можете прочитать в статье: [_Произведение Кронекера_](https://ru.wikipedia.org/wiki/%D0%9F%D1%80%D0%BE%D0%B8%D0%B7%D0%B2%D0%B5%D0%B4%D0%B5%D0%BD%D0%B8%D0%B5_%D0%9A%D1%80%D0%BE%D0%BD%D0%B5%D0%BA%D0%B5%D1%80%D0%B0)

Есть и другие нужные тензорные операции, например, чуть больший список вы можете найти в [_статье_](https://habr.com/ru/post/369925/) или в рекомендованной литературе по квантовой механике.

## Рекомендации литературы

- Quantum Mechanics: The Theoretical Minimum Illustrated Edition by Leonard Susskind, Art Friedman {cite}`susskind2014quantum` или его русский перевод {cite}`susskind2014quantum-ru`. Книга сочетает в себе довольно строгий формализм вместе с интуицией квантовой механики. Главы построены в виде конкретных примеров или задач, которые понимают, зачем та или иная теория необходима.
- Mathematics for machine learning by Marc Peter Deisenroth, A. Aldo Faisal, and Cheng Soon Ong {cite}`deisenroth2020mathematics` - отличная книжка чтобы освежить воспоминания о базовых алгоритмах в машинном обучении и о математике, которая применяется в них. [_Доступна бесплатная электронная версия_](https://mml-book.github.io/book/mml-book.pdf).
- Deep Learning by Ian Goodfellow, Yoshua Bengio, Aaron Courville {cite}`Goodfellow-et-al-2016` - отличная книжка, чтобы разобраться в основах глубокого обучения, чем-то может заменить предыдущую книгу, отличный старт, если вы хотите разобраться в автоэнкодерах или в других нейросетевых моделях.
[_Доступна бесплатная электронная версия_](https://www.deeplearningbook.org/).

## Что мы узнали

- произвол со скобками
- Гильбертовы пространства
- Эрмитовый оператор
- Унитарный оператор
- Примеры различных операторов
