---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(deutschs_algorithm)=

# Задача Дойча

**Задача Дойча** (в английском варианте - **Deutsch's algorithm**) - это один из первых алгоритмов, показавших, что квантовый компьютер может решать задачи особым способом, отличающимся как от алгоритмов классического компьютера, так и от интуиции и здравого смысла человека. При этом такое решение может занимать меньшее количество шагов. 

Нужно прежде всего сказать, что задача Дойча не имеет практического применения, зато она является простейшим примером, с помощью которого можно понять, в чем состоит отличие квантовых алгоритмов от классических. Данный алгоритм был предложен в 1985 году, когда квантовых компьютеров еще не было, а практически он был реализован в 1998 году на 2-кубитном квантовом компьютере, работавшем на принципах ядерно-магнитного резонанса.

Итак, в чем состоит задача, которую решает алгоритм? Представьте, что у вас есть функция, которая представляет собой "черный ящик", принимающий на вход число из множества $\{0, 1\}$. Функция неким образом обрабатывает входное значение и возвращает число из этого же множества, то есть либо $0$, либо $1$. Нам известно, что эта функция принадлежит либо к классу сбалансированных функций, либо к классу константных функций (которые мы также можем называть несбалансированными). Задача алгоритма - установить, к какому классу принадлежит функция.

Рассмотрим все варианты этих двух классов функций. Всего их четыре, то есть по две функции в каждом классе. Начнем с несбалансированных:
<br/>
<br/>
<b>1). $f_1(x) = 0$</b>
<br/>
Это функция, всегда возвращающая $0$, независимо от входного значения. 
<br/>
Для нее справедливы выражения: 
<br/>
$f_1(0) = 0$
<br/>
$f_1(1) = 0$
<br/>

<b>2). $f_2(x) = 1$ </b>
<br/>
Такая функция всегда возвращает $1$, то есть верно следующее: 
<br/>
$f_2(0) = 1$
<br/>
$f_2(1) = 1$
<br/>

Ну а теперь посмотрим на сбалансированные функции. 
<br/>
Для них характерно то, что они могут возвращать как $0$, так и $1$. В этом и заключается "баланс".
<br/>
<br/>
<b>3). $f_3(x) = x$</b>
<br/>
Это тождественная функция, которая ничего не делает с входным значением.
<br/> 
Для нее справедливо следующее:
<br/>
$f_3(0) = 0$
<br/>
$f_3(1) = 1$
<br/>

<b>4). $f_4(x) = NOT \; x$</b>
<br/>
А вот эта функция инвертирует входное значение, то есть возвращает не то число, 
<br/>
которое было подано на вход, а другое:
<br/>
$f_4(0) = 1$
<br/>
$f_4(1) = 0$
<br/>

Классический компьютер справляется с задачей за два шага. Например, нам дана некоторая функция-"черный ящик", и мы должны установить, сбалансирована ли она.
На первом шаге мы отправляем в функцию входное значение $0$. Допустим, мы получили на выходе также $0$. Мы можем сказать, что данная функция - либо $f_1$
(константная функция, всегда возвращающая $0$), либо $f_3$ (сбалансированная функция, не меняющая входное значение). Для окончательного решения мы должны сделать еще один шаг - отправить в функцию значение $1$. Если при этом мы получим опять $0$, то это функция $f_1$, а если получили на выходе $1$, то искомая функция - $f_3$.

Способа, с помощью которого на классическом компьютере можно за одно действие установить, сбалансирована функция или нет, не существует. И здесь свое преимущество показывает квантовый компьютер: он может установить класс функции за одно действие.

Для начала рассмотрим простейшую схему, с помощью которой можно отправлять число на вход и получать ответ от черного ящика:
```{figure} /_static/qcblock/deutschs_algorithm/scheme_1.png
:name: scheme_1
:width: 400px

Схема 1.
```
Неизвестная функция обозначена как $U_f$. Обратите внимание, что в этой схеме используются два кубита. Это нужно для того, чтобы информация, с которой работает квантовый компьютер, не стиралась. В квантовом компьютере важно, чтобы все действия с кубитами (кроме операции измерения) были обратимыми, а для этого информация должна сохраняться. В верхнем кубите будет записано входное значение, а в нижнем - выходное значение функции. Таким образом, входное значение не будет перезаписано значением, которое вернет функция.

Но нам важно будет не только сохранить значение $|x\rangle$, но также и не разрушить $|y\rangle$. Так как кубит y очевидно имеет некоторое изначальное значение, мы не можем его просто перезаписать тем числом, которое выдаст функция $f(x)$. Здесь на помощь приходит операция исключающее ИЛИ - $XOR$ (также ее можно называть сложением по модулю 2), обозначенная на схеме как $\oplus$. В процессе работы черный ящик $U_f$ не только находит значение $f(x)$, но и применяет исключающее ИЛИ к значениям $y$ и $f(x)$. 
<br/>
Операции $XOR$ соответствует такая таблица истинности:

| a | b | a XOR b |
|:-:|:-:|:-------:|
| 0 | 0 |    0    |
| 0 | 1 |    1    |
| 1 | 0 |    1    |
| 1 | 1 |    0    |

Операция $XOR$ хороша для нас тем, что она не разрушает значение $|y\rangle$, так как является обратимой. Убедиться в этом можно, проверив тождество:
<br/>
$(a \oplus b) \oplus b = a$

*Схема 1* пока что не дает преимущества по сравнению с классическим компьютером, но мы можем ее немного усовершенствовать:
```{figure} /_static/qcblock/deutschs_algorithm/scheme_2.png
:name: scheme_2
:width: 500px

Схема 2.
```
В новой схеме оба кубита вначале будут находиться в состоянии $|0\rangle$. Затем мы применим к верхнему кубиту оператор Адамара, а к нижнему - гейт $X$, а затем так же, как и к верхнему, оператор Адамара. Тем самым мы приведем оба кубита в состояние суперпозиции перед тем, как они попадут на вход функции $U_f$.
Верхний кубит будет находиться в такой суперпозиции:
<br/>
$|x\rangle = \frac{1}{\sqrt{2}}|0\rangle + \frac{1}{\sqrt{2}}|1\rangle,$
<br/>
а нижний - в такой:
<br/>
$|x\rangle = \frac{1}{\sqrt{2}}|0\rangle - \frac{1}{\sqrt{2}}|1\rangle.$

После того, как $U_f$ отрабатывает, нижний кубит, как это ни странно, уже нас не интересует, так что к нему операции больше не применяется, и его измерение также не производится.

Дело в том, что ответ на вопрос о том, сбалансирована функция $f(x)$ или нет, будет нами получен из верхнего кубита после того, как на него подействует оператор Адамара и будет произведено измерение.

В том случае, если функция сбалансирована, результат измерения верхнего кубита будет равен $1$, а если несбалансирована - $0$. 

Разберемся подробнее, почему это происходит.
