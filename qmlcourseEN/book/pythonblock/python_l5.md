---
jupytext:
  formats: md:myst
  text_representation:
    extension: .md
    format_name: myst
kernelspec:
  display_name: Python 3
  language: python
  name: python3
---

(python_l5)=

# Условные конструкции, булева логика и сравнения

Автор(ы):

- [Котенков Игорь](https://github.com/stalkermustang)


## Описание лекции

В этой лекции мы расскажем про:
- `if`/`else`-конструкции и условия;
- тип `bool`;
- операторы сравнения;
- блоки кода и отступы.

## Ветвление логики

В прошлых лекциях мы рассмотрели программы с линейной структурой: сначала выполнялась первая конструкция (например, объявление переменной), затем вторая (преобразование переменной или расчет по формуле), после -- третья (`print` для вывода результатов). Можно сказать, что происходило последовательное исполнение команд, причем каждая инструкция выполнялась **обязательно**. Но что делать, если хочется опираться на обстоятельства и принимать решения о том, выполнять одну часть кода или другую?

Допустим, по числу `x` нужно определить его абсолютную величину, то есть модуль. Программа должна напечатать значение переменной `x`, если `x > 0` или же величину `-x` в противном случае (`-(-5) = 5`). Эту логику можно записать следующим образом:

```{code-cell} ipython3
x = -3  # попробуйте поменять значение переменной

if x > 0:
    print("Исходный x больше нуля")
    print(x)
else:
    print("Исходный x меньше или равен нулю")
    print(-x)
```

В этой программе используется условная инструкция `if` (в переводе с английского _"если"_). `if` -- это ключевое зарезервированное слово (так _нельзя назвать свою переменную_), указывающее на **условную конструкцию**. После `if` следует указать вычислимое выражение, которое **можно проверить на истинность** (то есть можно сказать, правда это или нет). Общий вид конструкции следующий:

```python
if (Условие):
    <Блок инструкций 1>
else:
    <Блок инструкций 2>
```

`else` -- тоже ключевое слово (в переводе -- _"иначе"_). Таким образом, можно в голове придерживаться такой интерпретации: "**если** условие верно (истинно), **то** выполни первый блок команд, **иначе** выполни второй блок".

Условная инструкция содержит как минимум ключевое слово `if` (единожды), затем может идти любое количество (включая ноль) блоков с условием `else if <условие>` (_иначе если_, то есть будет выполнена проверка нового условия в случае, если первая проверка в `if` не прошла), затем -- опционально -- конструкция `else`. Логика чтения и выполнения кода сохраняет порядок **сверху вниз**. Как только одно из условий будет выполнено, выполнится соответствующая инструкция (или набор инструкций), а все последующие блоки будут проигнорированы. Это проиллюстрировано в коде:


```{code-cell} ipython3
x = -3.8  # попробуйте поменять значение переменной

if x > 0:
    print('x больше нуля')
elif x < 0:  # можно написать "else if x < 0:"
    print('x меньше нуля')
else:
    print('x в точности равен нулю')
print('Такие дела!')
```

Понятно, что `x` не может одновременно быть и больше нуля, и меньше (или равен ему). Среди всех трех `print`-блоков будет выполнен **только один**. Если `x` действительно больше нуля, то второе условие (`x < 0`) даже не будет проверяться -- `Python` сразу же перейдет к последней строке и выведет надпись "Такие дела!".

Чтобы лучше разобраться в том, как работает код, можно использовать **визуализаторы** -- например, [такой](https://pythontutor.com/visualize.html#mode=edit). Прогоняйте через него весь код (даже в несколько строк) и сверяйте со своими ожиданиями от его работы.

## А что вообще такое эти ваши условия?

Выше было указано, что после конструкций `if`/`else if` необходимо указать **условие**, которое еще и должно быть истинным или ложным ("правда или нет"). Давайте попробуем определить необходимый **тип** переменной.

```{code-cell} ipython3
x = -3.8

condition_1 = x > 0
condition_2 = x < 0

print(condition_1, type(condition_1))
print(condition_2, type(condition_2))
```

Видно, что оба условия имеют один и тот же тип - `bool`, то есть `boolean`. По [определению](https://developer.mozilla.org/ru/docs/Glossary/Boolean):

> Boolean (Булев, Логический тип данных) -- примитивный тип данных в информатике, которые могут принимать **два возможных значения**, иногда называемых истиной (True) и ложью (False).

Оказывается, что в коде выше мы получили **ВСЕ** возможные варианты булевой переменной -- это истина (`True`, пишется только с заглавной буквы) и ложь (`False`, аналогично). Никаких других значений быть для условия не может. Вот такой это простой тип данных.

## Способы получения `bool`

Какими вообще могут быть условия? Как с ними можно обращаться? Согласно [официальной документации](https://docs.python.org/3/library/stdtypes.html), в `Python` есть такие операторы сравнения:

```{figure} /_static/pythonblock/bool_ifelse_l5/operators_table.png
:name: operators_table
:width: 400px

Все операции сравнения работают нативно (так же, как и в математике)
```

```{code-cell} ipython3
print(3.0 > 3)
print(3.0 == 3)
```

Здесь практически нечего рассматривать, операторы сравнения они и в `Python` операторы. Куда интереснее принцип **объединения различных условий в одно** -- для создания комплексной логики.

Пусть стоит задача определения четверти точки по ее координатам на двумерной плоскости. Решение такой задачи может быть записано следующим образом:

```{code-cell} ipython3
x = -3.6
y = 2.5432

if x > 0:
    if y > 0:
        # x > 0, y > 0
        print("Первая четверть")
    else:
        # x > 0, y < 0
        print("Четвертая четверть")
else:
    if y > 0:
        # x < 0, y > 0
        print("Вторая четверть")
    else:
        # x < 0, y < 0
        print("Третья четверть")
```

Пример показывает, что выполняемым блоком кода может быть любой блок `Python`, включая новый логический блок с `if-else` конструкцией. Однако его можно сократить с помощью **логических операторов** `and`, `or` и `not`. Это стандартные логические операторы [Булевой алгебры](https://ru.wikipedia.org/wiki/%D0%91%D1%83%D0%BB%D0%B5%D0%B2%D0%B0_%D0%B0%D0%BB%D0%B3%D0%B5%D0%B1%D1%80%D0%B0).

Логическое **И** является бинарным оператором (то есть оператором с двумя операндами: левым и правым) и имеет вид `and`. Оператор `and` возвращает `True` тогда и только тогда, когда **оба его операнда имеют значение** `True`.

Логическое **ИЛИ** является бинарным оператором и возвращает `True` тогда и только тогда, когда **хотя бы один операнд равен** `True`. Оператор "логическое ИЛИ" имеет вид `or`.

Логическое **НЕ** (отрицание) является унарным (то есть **с одним операндом**) оператором и имеет вид `not`, за которым следует единственный операнд. Логическое НЕ возвращает `True`, **если операнд равен** `False` и **наоборот**.

Эти правила необходимо запомнить для успешного создания сложных условий с целью разделения логики, заложенной в `Python`-коде.

Проиллюстрируем правила в коде на простых примерах. Обратите внимание на то, как можно объявлять `bool`-переменные -- это не сложнее, чем создание целочисленного значения:

```{code-cell} ipython3
true_value = True
false_value = False

# False потому, что один из операндов является False
some_value = true_value and false_value
print(some_value)

# True потому, что хотя бы один из операндов равен True
some_value = true_value or false_value
print(some_value)

# отрицание True (истины) есть False (ложь)
some_value = not true_value
print(some_value == false_value)

# пример сложного условия - порядок лучше в явном виде задавать скобками
hard_condition = (not true_value or false_value) or (true_value != false_value)
print(hard_condition)
```

Теперь попробуем их применить на приближенных к практике примерах:

```{code-cell} ipython3
x = -3.6
y = 2.5432

if x > 0 and y > 0:  # конструкция заменяет два вложенных if
    print("Первая четверть")
elif x > 0 and y < 0:
    print("Четвертая четверть")
elif y > 0:
    print("Вторая четверть")
else:
    print("Третья четверть")

# определим, большое ли число x (в терминах модуля)
x_is_small = (x < 3) and (x > -3)
# число большое, если оно не маленькое (по модулю)
x_is_large = not x_is_small  # можно отрицать факт малости x

print('Is x small? ', x_is_small)
print('Is x large? ', x_is_large)

# так тоже можно писать - на манер неравенств в математике
another_x_is_small = -3 < x < 3
print(another_x_is_small)
print(another_x_is_small == x_is_small)
```

Так как вторая переменная `x_is_large` -- это отрицание (`not`) первой (`x_is_small`), то они **никогда** не будут равны.

## Блоки кода и отступы

В примерах выше вы наверняка заметили упоминание термина "блок кода", а также откуда-то взявшиеся отступы после условий, и это не случайно. Во-первых, давайте признаем, что так условные конструкции (особенно вложенные!) читать куда легче, и глаза не разбегаются. Во-вторых, это особенность языка `Python` -- здесь не используются скобки `{}` для указания блоков, все форматирование происходит с помощью отступов. Отступы **всегда** добавляются в строки кода **после двоеточия**.

Для выделения блока инструкций (строк кода, выполняющихся подряд при любых условиях), относящихся к инструкциям `if`, `else` или другим, изучаемым далее, в языке `Python` используются **отступы**. Все инструкции, которые относятся к одному блоку, должны иметь **равную величину отступа**, то есть одинаковое число **пробелов в начале строки**. В качестве отступа [PEP 8](https://www.python.org/dev/peps/pep-0008/#tabs-or-spaces) рекомендует использовать **отступ в четыре пробела** и не рекомендует использовать символ табуляции. Если нужно сделать еще одно вложение блока инструкций, достаточно добавить еще четыре пробела (см. пример выше с поиском четверти на плоскости).
```{tip}
Хоть и не рекомендуется использовать символ табуляции для создания отступов, кнопка `Tab` на вашей клавиатуре в `Jupyter`-ноутбуке (при курсоре, указывающим на начало строки кода) создаст отступ в четыре пробела. Пользуйтесь этим, чтобы не перегружать клавишу пробела лишними постукиваниями :).
```

## Что мы узнали из лекции

- Для задания логики выполнения кода и создания нелинейности используются **условные инструкции**, поскольку они следуют некоторым условиям.
- Условная инструкция задается ключевым словом `if`, после которого может следовать несколько (от нуля) блоков `else if`/`elif`, и -- опционально -- в конце добавляется `else`, если ни один из блоков выше не сработал.
- Условия должны быть **булевого типа** (`bool`) и могут принимать **всего два значения** -- `True` и `False`. Выполнится тот блок кода, который задан истинным (`True`) условием (и только первый!).
- Условные конструкции можно вкладывать друг в друга, а также объединять с помощью **логических операторов** `and`, `or` и `not`.
- **Блок кода** -- это несколько подряд идущих команд, которые будут выполнены последовательно.
- Чтобы выделить блок кода после условия, используйте **отступы** -- четыре пробела.
- Чтобы создать отступ в `Jupter`, нужно нажать `Tab` в начале строки кода.
